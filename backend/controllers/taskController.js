import Task from "../models/Task.js";
import Session from "../models/Session.js";
import { transporter } from "../utils/mailer.js";
import { uploadToDrive } from "../utils/google.js";
import { validateEmail } from "../utils/emailValidation.js"; // âœ… VOTRE VALIDATEUR
import PDFDocument from "pdfkit";
import fs from "fs";
import path from "path";
import mongoose from "mongoose";
export const stopSession = async (req, res) => {
  try {
    const { sessionId } = req.params;

    const session = await Session.findById(sessionId);
    if (!session) return res.status(404).json({ msg: "Session non trouvÃ©e" });

    if (!session.stoppedAt) {
      session.stoppedAt = new Date();
      session.duration = Math.floor((session.stoppedAt - session.startedAt) / 60000); // durÃ©e en minutes
    }

    await session.save();

    // ðŸ”½ Ajoute ce bloc ici :
    const task = await Task.findById(session.task);
    if (!task) return res.status(404).json({ msg: "TÃ¢che liÃ©e non trouvÃ©e" });

    task.timeSpent = (task.timeSpent || 0) + session.duration;
    await task.save();

    res.json({ msg: "Session arrÃªtÃ©e avec succÃ¨s", session });
  } catch (err) {
    console.error("Erreur stopSession:", err);
    res.status(500).json({ msg: "Erreur lors de l'arrÃªt de la session" });
  }
};


// âœ… GET - Statistiques dÃ©taillÃ©es par Ã©tat, module, catÃ©gorie (en heures et minutes)
export const getDetailedStats = async (req, res) => {
  try {
    const userEmail = req.user.email;

    const tasks = await Task.find({
      owners: userEmail,
      statut: { $ne: "supprimÃ©e" }
    }).select("statut module categorie dureeEstimee");

    const groupAndSum = (key) => {
      const grouped = {};
      for (const task of tasks) {
        const k = task[key] || "Non dÃ©fini";
        if (!grouped[k]) grouped[k] = 0;
        grouped[k] += task.dureeEstimee || 0;
      }
      return grouped;
    };

    const convertToHMin = (minutes) => {
      const h = Math.floor(minutes / 60);
      const m = minutes % 60;
      return `${h > 0 ? h + "h " : ""}${m}min`;
    };

    const tempsParEtat = Object.entries(groupAndSum("statut")).map(([etat, min]) => ({
      etat,
      minutes: min,
      format: convertToHMin(min)
    }));

    const tempsParModule = Object.entries(groupAndSum("module")).map(([mod, min]) => ({
      module: mod,
      minutes: min,
      format: convertToHMin(min)
    }));

    const tempsParCategorie = Object.entries(groupAndSum("categorie")).map(([cat, min]) => ({
      categorie: cat,
      minutes: min,
      format: convertToHMin(min)
    }));

    res.json({
      tempsParEtat,
      tempsParModule,
      tempsParCategorie
    });
  } catch (err) {
    console.error("Erreur getDetailedStats:", err);
    res.status(500).json({ msg: "Erreur lors du calcul des statistiques dÃ©taillÃ©es" });
  }
};

// âœ… GET toutes les tÃ¢ches de l'utilisateur avec pagination et filtres
export const getTasks = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 50,
      status,
      priority,
      module,
      category,
      sortBy = "dateEcheance",
      sortOrder = "asc",
      search,
      dateFrom,
      dateTo,
      includeDeleted = false
    } = req.query;

    // Construire le filtre
    let filter = { owners: req.user.email };

    // âœ… Gestion du statut (avec ou sans tÃ¢ches supprimÃ©es)
    if (includeDeleted === 'true') {
      filter.includeDeleted = true;
    } else {
      filter.statut = { $ne: 'supprimÃ©e' };
    }

    if (status) filter.statut = status;
    if (priority) filter.priorite = priority;
    if (module) filter.module = new RegExp(module, 'i');
    if (category) filter.categorie = category;

    // Filtre par recherche textuelle
    if (search && search.trim()) {
      filter.$or = [
        { titre: new RegExp(search.trim(), 'i') },
        { description: new RegExp(search.trim(), 'i') },
        { module: new RegExp(search.trim(), 'i') },
        { tags: new RegExp(search.trim(), 'i') }
      ];
    }

    // Filtre par date
    if (dateFrom || dateTo) {
      filter.dateEcheance = {};
      if (dateFrom) filter.dateEcheance.$gte = new Date(dateFrom);
      if (dateTo) filter.dateEcheance.$lte = new Date(dateTo);
    }

    // Pagination
    const skip = (parseInt(page) - 1) * parseInt(limit);

    // Tri
    const sortOptions = {};
    sortOptions[sortBy] = sortOrder === 'desc' ? -1 : 1;

    const tasks = await Task.find(filter)
      .sort(sortOptions)
      .skip(skip)
      .limit(parseInt(limit))
      .lean(); // âœ… Utiliser lean() pour de meilleures performances

    const total = await Task.countDocuments(filter);

    res.json({
      tasks,
      pagination: {
        current: parseInt(page),
        total: Math.ceil(total / parseInt(limit)),
        count: total,
        hasNext: skip + parseInt(limit) < total,
        hasPrev: parseInt(page) > 1
      }
    });
  } catch (err) {
    console.error("Erreur getTasks:", err);
    res.status(500).json({ 
      msg: "Erreur serveur lors de la rÃ©cupÃ©ration des tÃ¢ches", 
      error: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
};

// âœ… POST crÃ©er une tÃ¢che (amÃ©liorÃ©)
export const createTask = async (req, res) => {
  try {
    // âœ… Validation des champs obligatoires
    const { titre, module, dateEcheance } = req.body;
    
    if (!titre || !titre.trim()) {
      return res.status(400).json({ msg: "Le titre est obligatoire" });
    }
    
    if (!module || !module.trim()) {
      return res.status(400).json({ msg: "Le module est obligatoire" });
    }
    
    if (!dateEcheance) {
      return res.status(400).json({ msg: "La date d'Ã©chÃ©ance est obligatoire" });
    }

    // âœ… Validation de la date
    const echeanceDate = new Date(dateEcheance);
    if (isNaN(echeanceDate.getTime())) {
      return res.status(400).json({ msg: "Date d'Ã©chÃ©ance invalide" });
    }

    // âœ… Validation de la durÃ©e estimÃ©e
    if (req.body.dureeEstimee && (isNaN(req.body.dureeEstimee) || req.body.dureeEstimee < 0)) {
      return res.status(400).json({ msg: "DurÃ©e estimÃ©e invalide" });
    }

    const task = await Task.create({
      ...req.body,
      user: req.user.id,
      owners: [req.user.email],
      titre: titre.trim(),
      module: module.trim()
    });

    console.log("TÃ¢che crÃ©Ã©e:", task._id, task.titre);
    res.status(201).json(task);
  } catch (err) {
    console.error("Erreur createTask:", err);
    
    if (err.name === 'ValidationError') {
      return res.status(400).json({ 
        msg: "Erreur de validation", 
        errors: Object.values(err.errors).map(e => e.message)
      });
    }
    
    res.status(400).json({ 
      msg: "Erreur lors de la crÃ©ation de la tÃ¢che", 
      error: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
};

// âœ… PUT mettre Ã  jour une tÃ¢che (amÃ©liorÃ©)
export const updateTask = async (req, res) => {
  try {
    const { id } = req.params;

    // âœ… Validation de l'ID
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ msg: "ID de tÃ¢che invalide" });
    }

    // âœ… Validation des donnÃ©es mises Ã  jour
    if (req.body.titre && !req.body.titre.trim()) {
      return res.status(400).json({ msg: "Le titre ne peut pas Ãªtre vide" });
    }

    if (req.body.module && !req.body.module.trim()) {
      return res.status(400).json({ msg: "Le module ne peut pas Ãªtre vide" });
    }

    if (req.body.dateEcheance) {
      const echeanceDate = new Date(req.body.dateEcheance);
      if (isNaN(echeanceDate.getTime())) {
        return res.status(400).json({ msg: "Date d'Ã©chÃ©ance invalide" });
      }
    }

    if (req.body.dureeEstimee && (isNaN(req.body.dureeEstimee) || req.body.dureeEstimee < 0)) {
      return res.status(400).json({ msg: "DurÃ©e estimÃ©e invalide" });
    }

    const updated = await Task.findOneAndUpdate(
      { _id: id, owners: req.user.email },
      {
        ...req.body,
        ...(req.body.titre && { titre: req.body.titre.trim() }),
        ...(req.body.module && { module: req.body.module.trim() })
      },
      { new: true, runValidators: true }
    );

    if (!updated) {
      return res.status(403).json({ msg: "TÃ¢che non trouvÃ©e ou non autorisÃ©e" });
    }

    console.log("TÃ¢che mise Ã  jour:", updated._id, updated.titre);
    res.json(updated);
  } catch (err) {
    console.error("Erreur updateTask:", err);
    
    if (err.name === 'ValidationError') {
      return res.status(400).json({ 
        msg: "Erreur de validation", 
        errors: Object.values(err.errors).map(e => e.message)
      });
    }
    
    res.status(400).json({ 
      msg: "Erreur lors de la mise Ã  jour de la tÃ¢che", 
      error: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
};

// âœ… DELETE supprimer une tÃ¢che (amÃ©liorÃ©)
export const deleteTask = async (req, res) => {
  try {
    const { id } = req.params;

    // âœ… Validation de l'ID
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ msg: "ID de tÃ¢che invalide" });
    }

    const deleted = await Task.findOneAndDelete({
      _id: id,
      owners: req.user.email
    });

    if (!deleted) {
      return res.status(403).json({ msg: "TÃ¢che non trouvÃ©e ou non autorisÃ©e" });
    }

    console.log("TÃ¢che supprimÃ©e:", deleted._id, deleted.titre);
    res.json({ msg: "TÃ¢che supprimÃ©e avec succÃ¨s", taskId: id });
  } catch (err) {
    console.error("Erreur deleteTask:", err);
    res.status(400).json({ 
      msg: "Erreur lors de la suppression de la tÃ¢che", 
      error: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
};

// âœ… Recherche avancÃ©e (amÃ©liorÃ©e)
export const searchTasks = async (req, res) => {
  try {
    const { 
      q, 
      module, 
      priorite, 
      statut, 
      dateFrom, 
      dateTo,
      limit = 20,
      includeDeleted = false
    } = req.query;
    
    let filter = { owners: req.user.email };
    
    // âœ… Gestion des tÃ¢ches supprimÃ©es
    if (includeDeleted !== 'true') {
      filter.statut = { $ne: 'supprimÃ©e' };
    }
    
    // âœ… Recherche textuelle amÃ©liorÃ©e
    if (q && q.trim()) {
      const searchRegex = new RegExp(q.trim(), 'i');
      filter.$or = [
        { titre: searchRegex },
        { description: searchRegex },
        { module: searchRegex },
        { tags: searchRegex }
      ];
    }
    
    // Filtres additionnels
    if (module) filter.module = new RegExp(module, 'i');
    if (priorite) filter.priorite = priorite;
    if (statut) filter.statut = statut;
    
    // Filtre par date
    if (dateFrom || dateTo) {
      filter.dateEcheance = {};
      if (dateFrom) filter.dateEcheance.$gte = new Date(dateFrom);
      if (dateTo) filter.dateEcheance.$lte = new Date(dateTo);
    }
    
    const tasks = await Task.find(filter)
      .sort({ 
        // âœ… Tri par pertinence si recherche textuelle
        ...(q ? { score: { $meta: "textScore" } } : {}),
        dateEcheance: 1 
      })
      .limit(parseInt(limit))
      .lean();
      
    res.json({
      results: tasks,
      count: tasks.length,
      query: q,
      filters: { module, priorite, statut, dateFrom, dateTo }
    });
  } catch (err) {
    console.error("Erreur searchTasks:", err);
    res.status(500).json({ 
      msg: "Erreur lors de la recherche", 
      error: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
};

// âœ… PUT partager une tÃ¢che avec un autre utilisateur Gmail/Universitaire (UTILISE VOTRE VALIDATEUR)
export const shareTask = async (req, res) => {
  const { id } = req.params;
  const { email } = req.body;

  // âœ… Validation de l'ID
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ msg: "ID de tÃ¢che invalide" });
  }

  // âœ… UTILISATION DE VOTRE VALIDATEUR ASYNC
  try {
    const emailValidation = await validateEmail(email);
    if (!emailValidation.isValid) {
      return res.status(400).json({ 
        msg: emailValidation.reason,
        examples: [
          "exemple@gmail.com", 
          "etudiant@um5r.ac.ma", 
          "prof@uh2c.ac.ma", 
          "student@uca.ac.ma",
          "user@ump.ac.ma"
        ]
      });
    }
  } catch (validationError) {
    console.error("Erreur validation email:", validationError);
    return res.status(400).json({ 
      msg: "Erreur lors de la validation de l'email",
      details: validationError.message
    });
  }

  // âœ… EmpÃªcher de partager avec soi-mÃªme
  if (email === req.user.email) {
    return res.status(400).json({ msg: "Vous ne pouvez pas partager une tÃ¢che avec vous-mÃªme" });
  }

  try {
    const task = await Task.findById(id);
    if (!task) {
      return res.status(404).json({ msg: "TÃ¢che introuvable" });
    }

    if (!task.owners.includes(req.user.email)) {
      return res.status(403).json({ msg: "Non autorisÃ© Ã  partager cette tÃ¢che" });
    }

    if (task.owners.includes(email)) {
      return res.status(400).json({ msg: "Cette tÃ¢che est dÃ©jÃ  partagÃ©e avec cet utilisateur" });
    }

    await task.shareWith(email);

    // âœ… Envoi d'email amÃ©liorÃ© et clean
    try {
      await transporter.sendMail({
        from: `"FocusTÃ¢che" <${process.env.GMAIL_USER}>`,
        to: email,
        subject: "Une tÃ¢che vous a Ã©tÃ© partagÃ©e",
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #3b82f6;">Nouvelle tÃ¢che partagÃ©e</h2>
            <p>Bonjour !</p>
            <p>Une tÃ¢che a Ã©tÃ© partagÃ©e avec vous dans FocusTÃ¢che.</p>
            <div style="background: #f1f5f9; padding: 20px; border-radius: 8px; margin: 20px 0;">
              <h3 style="margin: 0 0 10px 0; color: #1e293b;">${task.titre}</h3>
              <p style="margin: 5px 0; color: #64748b;"><strong>Module:</strong> ${task.module}</p>
              <p style="margin: 5px 0; color: #64748b;"><strong>PrioritÃ©:</strong> ${task.priorite}</p>
              <p style="margin: 5px 0; color: #64748b;"><strong>Ã‰chÃ©ance:</strong> ${new Date(task.dateEcheance).toLocaleDateString('fr-FR')}</p>
              ${task.description ? `<p style="margin: 10px 0 0 0; color: #475569;"><strong>Description:</strong> ${task.description}</p>` : ''}
            </div>
            <p style="margin: 5px 0; color: #64748b;"><strong>PartagÃ©e par:</strong> ${req.user.email}</p>
            <p>Connectez-vous Ã  l'application pour consulter et collaborer sur cette tÃ¢che.</p>
            <hr style="margin: 30px 0; border: none; border-top: 1px solid #e2e8f0;">
            <p style="font-size: 12px; color: #94a3b8;">FocusTÃ¢che - Organisez votre travail efficacement</p>
          </div>
        `
      });
    } catch (emailError) {
      console.error("Erreur envoi email:", emailError);
      // Ne pas faire Ã©chouer la requÃªte si l'email Ã©choue
    }

    console.log("TÃ¢che partagÃ©e:", task._id, "avec", email);
    res.json({ 
      msg: "TÃ¢che partagÃ©e avec succÃ¨s", 
      task,
      sharedWith: email,
      totalOwners: task.owners.length
    });
  } catch (err) {
    console.error("Erreur shareTask:", err);
    res.status(500).json({ 
      msg: "Erreur lors du partage", 
      error: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
};

// âœ… GET statistiques sur les tÃ¢ches (amÃ©liorÃ©es)
export const getTaskStats = async (req, res) => {
  try {
    // âœ… Utiliser l'agrÃ©gation pour de meilleures performances
    const statsResult = await Task.aggregate([
      { 
        $match: { 
          owners: req.user.email,
          statut: { $ne: 'supprimÃ©e' }
        }
      },
      {
        $group: {
          _id: null,
          total: { $sum: 1 },
          aFaire: { $sum: { $cond: [{ $eq: ["$statut", "Ã  faire"] }, 1, 0] } },
          enCours: { $sum: { $cond: [{ $eq: ["$statut", "en cours"] }, 1, 0] } },
          terminees: { $sum: { $cond: [{ $eq: ["$statut", "terminÃ©e"] }, 1, 0] } },
          haute: { $sum: { $cond: [{ $eq: ["$priorite", "haute"] }, 1, 0] } },
          moyenne: { $sum: { $cond: [{ $eq: ["$priorite", "moyenne"] }, 1, 0] } },
          basse: { $sum: { $cond: [{ $eq: ["$priorite", "basse"] }, 1, 0] } },
          enRetard: { 
            $sum: { 
              $cond: [
                { 
                  $and: [
                    { $ne: ["$statut", "terminÃ©e"] },
                    { $lt: ["$dateEcheance", new Date()] }
                  ]
                }, 
                1, 
                0
              ] 
            }
          },
          tempsTotal: { $sum: "$timeSpent" },
          pomodorosTotal: { $sum: "$pomodoroCount" }
        }
      }
    ]);

    const stats = statsResult[0] || {
      total: 0, aFaire: 0, enCours: 0, terminees: 0,
      haute: 0, moyenne: 0, basse: 0, enRetard: 0,
      tempsTotal: 0, pomodorosTotal: 0
    };

    // âœ… Calcul des pourcentages
    const total = stats.total;
    const pourcentages = {
      "Ã  faire": total > 0 ? Math.round((stats.aFaire / total) * 100) : 0,
      "en cours": total > 0 ? Math.round((stats.enCours / total) * 100) : 0,
      "terminÃ©e": total > 0 ? Math.round((stats.terminees / total) * 100) : 0
    };

    res.json({
      total: stats.total,
      stats: {
        "Ã  faire": stats.aFaire,
        "en cours": stats.enCours,
        "terminÃ©e": stats.terminees
      },
      priorites: {
        haute: stats.haute,
        moyenne: stats.moyenne,
        basse: stats.basse
      },
      pourcentages,
      metrics: {
        enRetard: stats.enRetard,
        tempsTotal: stats.tempsTotal, // en secondes
        tempsFormate: `${Math.floor(stats.tempsTotal / 3600)}h ${Math.floor((stats.tempsTotal % 3600) / 60)}min`,
        pomodorosTotal: stats.pomodorosTotal,
        productivite: total > 0 ? Math.round((stats.terminees / total) * 100) : 0
      }
    });
  } catch (err) {
    console.error("Erreur getTaskStats:", err);
    res.status(500).json({ 
      msg: "Erreur lors du calcul des statistiques", 
      error: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
};
// âœ… GET - Exporter UNE tÃ¢che en PDF

export const exportSingleTask = async (req, res) => {
  try {
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ msg: "ID de tÃ¢che invalide" });
    }

    const task = await Task.findOne({
      _id: id,
      owners: req.user.email,
      statut: { $ne: 'supprimÃ©e' }
    });

    if (!task) {
      return res.status(404).json({ msg: "TÃ¢che non trouvÃ©e" });
    }

    const doc = new PDFDocument({ margin: 40 });

    // âœ… Configuration des headers
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", `attachment; filename=tache-${id}.pdf`);

    // âœ… Envoie direct du PDF au client
    doc.pipe(res);

    doc.fontSize(20).text("FocusTÃ¢che - Export de tÃ¢che", { align: 'center' });
    doc.moveDown();

    doc.fontSize(14).text(`Titre : ${task.titre}`);
    doc.text(`Module : ${task.module}`);
    doc.text(`PrioritÃ© : ${task.priorite}`);
    doc.text(`Statut : ${task.statut}`);
    doc.text(`Ã‰chÃ©ance : ${new Date(task.dateEcheance).toLocaleDateString('fr-FR')}`);
    if (task.description) doc.text(`Description : ${task.description}`);
    doc.moveDown();
    doc.text(`ExportÃ© par : ${req.user.email}`, { align: 'right' });

    doc.end(); // ðŸš€ Lance la gÃ©nÃ©ration
  } catch (err) {
    console.error("Erreur exportSingleTask:", err);
    res.status(500).json({ msg: "Erreur lors de l'export", error: err.message });
  }
};

// âœ… GET exporter les tÃ¢ches en PDF (amÃ©liorÃ©)
export const exportTasks = async (req, res) => {
  try {
    const { status, priority, module, dateFrom, dateTo } = req.query;
    
    // âœ… Construire le filtre pour l'export
    let filter = { owners: req.user.email, statut: { $ne: 'supprimÃ©e' } };
    if (status) filter.statut = status;
    if (priority) filter.priorite = priority;
    if (module) filter.module = new RegExp(module, 'i');
    if (dateFrom || dateTo) {
      filter.dateEcheance = {};
      if (dateFrom) filter.dateEcheance.$gte = new Date(dateFrom);
      if (dateTo) filter.dateEcheance.$lte = new Date(dateTo);
    }

    const tasks = await Task.find(filter).sort({ dateEcheance: 1 });

    // âœ… CrÃ©er le dossier exports s'il n'existe pas
    const exportsDir = "exports";
    if (!fs.existsSync(exportsDir)) {
      fs.mkdirSync(exportsDir, { recursive: true });
    }

    const fileName = `tasks-${req.user.id}-${Date.now()}.pdf`;
    const filePath = path.join(exportsDir, fileName);

    const doc = new PDFDocument({ margin: 50 });
    doc.pipe(fs.createWriteStream(filePath));

    // âœ… En-tÃªte amÃ©liorÃ©
    doc.fontSize(24).text("Mes TÃ¢ches FocusTÃ¢che", { align: 'center' });
    doc.fontSize(12).text(`ExportÃ© le ${new Date().toLocaleDateString('fr-FR')} Ã  ${new Date().toLocaleTimeString('fr-FR')}`, { align: 'center' });
    doc.text(`Utilisateur: ${req.user.email}`, { align: 'center' });
    doc.moveDown(2);

    // âœ… Statistiques
    doc.fontSize(14).text(`RÃ©sumÃ©: ${tasks.length} tÃ¢che(s) exportÃ©e(s)`, { underline: true });
    doc.moveDown(1);

    // âœ… Contenu des tÃ¢ches
    tasks.forEach((task, index) => {
      const yPosition = doc.y;
      
      // VÃ©rifier si on a assez de place pour la tÃ¢che
      if (yPosition > 700) {
        doc.addPage();
      }

      doc.fontSize(12).text(`${index + 1}. ${task.titre}`, { continued: false });
      doc.fontSize(10)
         .text(`   Module: ${task.module}`)
         .text(`   PrioritÃ©: ${task.priorite}`)
         .text(`   Ã‰chÃ©ance: ${new Date(task.dateEcheance).toLocaleDateString('fr-FR')}`)
         .text(`   Statut: ${task.statut}`);
      
      if (task.description) {
        doc.text(`   Description: ${task.description}`);
      }
      
      if (task.dureeEstimee) {
        doc.text(`   DurÃ©e estimÃ©e: ${task.dureeEstimee} minutes`);
      }
      
      doc.moveDown(0.5);
    });

    doc.end();

    doc.on("finish", async () => {
      try {
        // âœ… Tentative d'upload vers Google Drive (optionnel)
        if (typeof uploadToDrive === 'function') {
          await uploadToDrive(filePath, `FocusTache_${req.user.email}_${Date.now()}.pdf`);
        }
      } catch (driveError) {
        console.warn("Avertissement upload Drive:", driveError.message);
        // Ne pas faire Ã©chouer l'export si Drive Ã©choue
      }
console.log("ðŸ“¦ Export PDF prÃªt Ã  Ãªtre envoyÃ© :", filePath);

      // âœ… TÃ©lÃ©chargement et nettoyage
      res.download(filePath, `mes-taches-${new Date().toISOString().split('T')[0]}.pdf`, (err) => {
        if (err) {
          console.error("Erreur tÃ©lÃ©chargement:", err);
        }
        
        // Nettoyer le fichier temporaire
        try {
          fs.unlinkSync(filePath);
        } catch (cleanupError) {
          console.warn("Avertissement nettoyage:", cleanupError.message);
        }
      });
    });

    doc.on("error", (err) => {
      console.error("Erreur gÃ©nÃ©ration PDF:", err);
      res.status(500).json({ msg: "Erreur lors de la gÃ©nÃ©ration du PDF" });
    });

  } catch (err) {
    console.error("Erreur exportTasks:", err);
    res.status(500).json({ 
      msg: "Erreur lors de l'exportation", 
      error: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
};